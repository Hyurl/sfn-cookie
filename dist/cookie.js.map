{"version":3,"sources":["webpack://SfnCookie/webpack/universalModuleDefinition","webpack://SfnCookie/webpack/bootstrap","webpack://SfnCookie/./src/index.ts"],"names":[],"mappings":"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","file":"cookie.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SfnCookie\"] = factory();\n\telse\n\t\troot[\"SfnCookie\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading wasm modules\n \tvar installedWasmModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// object with all compiled WebAssembly.Modules\n \t__webpack_require__.w = {};\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","export interface BaseCookieOptions {\n    /** How many seconds that this cookie should last. */\n    maxAge?: number;\n    /** Keep alive to a specified date or time. */\n    expires?: string | number | Date;\n    /** Honor same-site principle. */\n    sameSite?: \"Strict\" | \"Lax\";\n    /** Set cookie for a specified domain name. */\n    domain?: string;\n    /** Set cookie for a specified pathname. */\n    path?: string;\n    /** Only HTTP(s), not JavaScript, can access this cookie. */\n    httpOnly?: boolean;\n    /** The cookie won't be sent if not using HTTPS protocol. */\n    secure?: boolean;\n}\n\nexport interface CookieOptions extends BaseCookieOptions {\n    name?: string;\n    value?: string;\n}\n\nexport class Cookie implements CookieOptions {\n    name: string;\n    value: string;\n    maxAge: number;\n    expires: string | number | Date;\n    sameSite: \"Strict\" | \"Lax\";\n    domain: string;\n    path: string;\n    httpOnly: boolean;\n    secure: boolean;\n\n    /**\n     * @example new Cookie(\"username=Luna\")\n     * @example new Cookie(\"username=Luna; Max-Age=120; HttpOnly\")\n     * @example new Cookie(\"username\", \"Luna\")\n     * @example new Cookie(\"username\", \"Luna\", { maxAge: 120, httpOnly: true })\n     * @example new Cookie({ name: \"username\", value: \"Luna\", maxAge: 120, httpOnly: true })\n     */\n    constructor(options: CookieOptions);\n    constructor(cookieStr: string);\n    constructor(name: string, value: string, options?: BaseCookieOptions);\n\n    constructor(input, value = null, options = null) {\n        if (typeof input === \"string\") {\n            if (value === null) {\n                Object.assign(this, parse(input));\n            } else {\n                Object.assign(this, { name: input, value }, options);\n            }\n        } else {\n            Object.assign(this, input);\n        }\n    }\n\n    /** Gets the serialized cookie string of the current instance. */\n    toString(): string {\n        return serialize(this);\n    }\n}\n\n/** Serializes an object or Cookie instance to a valid cookie string. */\nexport function serialize(data: Cookie | CookieOptions): string {\n    let {\n        name,\n        value,\n        maxAge,\n        expires,\n        sameSite,\n        domain,\n        path,\n        httpOnly,\n        secure\n    } = data;\n\n    if (!name) return \"\";\n\n    let str = encodeURIComponent(name) + \"=\" + encodeURIComponent(value);\n\n    if (maxAge)\n        str += \"; Max-Age=\" + maxAge;\n\n    if (expires) {\n        let err = \"Expires must be a valid date string or timestamp, or a Date instance.\";\n\n        if (expires instanceof Date) {\n            expires = expires.toUTCString();\n        } else if (typeof expires == \"number\" || typeof expires == \"string\") {\n            try {\n                expires = new Date(expires).toUTCString();\n            } catch (e) {\n                throw new TypeError(err);\n            }\n        } else {\n            throw new TypeError(err);\n        }\n\n        str += \"; Expires=\" + expires;\n    }\n\n    if (sameSite)\n        str += \"; SameSite=\" + sameSite;\n\n    if (domain)\n        str += \"; Domain=\" + domain;\n\n    if (path)\n        str += \"; Path=\" + path;\n\n    if (httpOnly)\n        str += \"; HttpOnly\";\n\n    if (secure)\n        str += \"; Secure\";\n\n    return str;\n}\n\n/** Parses a cookie string to a Cookie instance. */\nexport function parse(cookieStr: string): Cookie {\n    if (!cookieStr || typeof cookieStr !== \"string\") return null;\n\n    let pairs = cookieStr.split(/\\s*;\\s*/),\n        data: CookieOptions = { name: undefined, value: undefined };\n\n    for (let i in pairs) {\n        let pair = pairs[i].split(\"=\");\n\n        if (i == \"0\") {\n            data.name = decodeURIComponent(pair[0]);\n            data.value = decodeURIComponent(pair[1]);\n        } else {\n            let key = pair[0] == \"Max-Age\"\n                ? \"maxAge\"\n                : pair[0][0].toLowerCase() + pair[0].slice(1);\n\n            if (!isNaN(<any>pair[1])) {\n                data[key] = parseInt(pair[1]);\n            } else if (pair[1] === undefined) {\n                data[key] = true;\n            } else {\n                data[key] = pair[1];\n            }\n        }\n    }\n\n    return new Cookie(data);\n}\n\n/**\n * Parses a string as multiple cookies, useful for parsing\n * `document.cookie` and `req.headers.cookie`.\n */\nexport function parseMany(str: string): Cookie[] {\n    if (!str || typeof str !== \"string\") return [];\n\n    let pairs = str.split(/\\s*;\\s*/),\n        cookies = [];\n\n    for (let pair of pairs) {\n        cookies.push(new Cookie(pair));\n    }\n\n    return cookies;\n}\n\nexport default Cookie;"],"sourceRoot":""}